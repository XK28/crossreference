import os
import re
import io
import pandas as pd
import msoffcrypto
import tkinter as tk
from tkinter import simpledialog
from reportlab.lib.pagesizes import letter
from reportlab.platypus import (
    SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
)
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch

# -----------------------
# Interfaz gráfica para selección de tipo de validación
# -----------------------
tipo_validacion = None

def seleccionar_tipo(tipo):
    global tipo_validacion
    tipo_validacion = tipo
    ventana.destroy()

ventana = tk.Tk()
ventana.title("Seleccionar tipo de validación")
ventana.geometry("300x120")
tk.Label(ventana, text="Seleccione el tipo de validación:").pack(pady=10)
tk.Button(ventana, text="ACH XPRESS", width=20, command=lambda: seleccionar_tipo("ach")).pack(pady=5)
tk.Button(ventana, text="Cuenta Puente", width=20, command=lambda: seleccionar_tipo("puente")).pack(pady=5)
ventana.mainloop()

# -----------------------
# Solicitar contraseña (igual que antes)
# -----------------------
password = simpledialog.askstring("Contraseña", "Ingrese la contraseña del archivo Excel (dejar vacío si no tiene):")

# -----------------------
# Funciones auxiliares
# -----------------------
def extraer_id_7_inicio_exacto(s):
    """
    Extrae la secuencia NUMÉRICA que aparece AL INICIO de la cadena *solo si* esa
    secuencia tiene exactamente 7 dígitos. Si no cumple, devuelve None.
    (ej: '1234567abc' -> '1234567'; '20250624_xxx' -> None porque la secuencia
    inicial tiene 8 dígitos; 'ABC1234567' -> None porque no empieza con dígitos).
    """
    if s is None:
        return None
    s = str(s).strip()
    if not s:
        return None
    m = re.match(r'^(\d+)', s)   # captura dígitos consecutivos al inicio
    if not m:
        return None
    digits = m.group(1)
    if len(digits) == 7:
        return digits
    return None

def parse_amount_safe(x):
    """
    Trata de convertir x a float de forma tolerante:
    - elimina espacios y símbolos no numéricos salvo el punto y el signo negativo
    - rechaza valores vacíos o no convertibles -> devuelve None
    """
    if x is None or (isinstance(x, float) and pd.isna(x)):
        return None
    s = str(x).strip()
    if s == "":
        return None
    # reemplazar comas de millares (eliminar) - cuidado con coma decimal, pero los ejemplos usan punto
    s = s.replace(",", "")
    # eliminar cualquier caracter que no sea dígito, punto o signo menos
    s = re.sub(r'[^\d.\-]', '', s)
    if s in ("", ".", "-", "-.", ".-"):
        return None
    try:
        return float(s)
    except Exception:
        return None

# -----------------------
# Leer archivo de validación (ruta fija, GUI y password sin cambios)
# -----------------------
validacion_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\validacion"
archivos_validacion = [f for f in os.listdir(validacion_dir) if f.lower().endswith(('.xlsx', '.xlsm', '.csv'))]
if not archivos_validacion:
    raise FileNotFoundError("No se encontró archivo de validación en la carpeta ./validacion")
ruta_validacion = os.path.join(validacion_dir, archivos_validacion[0])

# lectura (CSV o Excel con posible cifrado)
if ruta_validacion.lower().endswith('.csv'):
    df_validar = pd.read_csv(
        ruta_validacion,
        header=None,
        dtype=str,
        sep='|',
        engine='python',
        on_bad_lines='skip'
    )
else:
    with open(ruta_validacion, "rb") as f:
        office_file = msoffcrypto.OfficeFile(f)
        try:
            enc = office_file.is_encrypted()
        except Exception:
            enc = bool(password)
        if enc:
            try:
                if password:
                    office_file.load_key(password=password)
                decrypted = io.BytesIO()
                office_file.decrypt(decrypted)
                decrypted.seek(0)
                df_validar = pd.read_excel(decrypted, engine="openpyxl", header=None)
            except Exception:
                # fallback intento lectura directa
                df_validar = pd.read_excel(ruta_validacion, engine="openpyxl", header=None)
        else:
            df_validar = pd.read_excel(ruta_validacion, engine="openpyxl", header=None)

# -----------------------
# Procesar validación: empezar desde la fila 1 y construir LLAVES según la opción
# (Cuenta Puente: columnas [1,3]; ACH: columnas [1,2] y si [2] nulo usar [1,3])
# Además ignorar filas donde los primeros dígitos no cumplan la regla exacta de 7 dígitos
# -----------------------
# Empezar desde fila 1 (descartar fila 0 si existe)
if len(df_validar) > 1:
    df_valid = df_validar.iloc[1:].reset_index(drop=True)
else:
    df_valid = df_validar.copy()

# asegurarnos de tener al menos la columna B (índice 1)
if df_valid.shape[1] <= 1:
    # no hay columna B: no hay filas válidas
    df_validar_proc = pd.DataFrame(columns=['LLAVE'])
else:
    # columna B siempre index 1
    colB = df_valid[1].astype(str)

    # construir series de ID y monto según el tipo
    ids_list = []
    monto_list = []

    if tipo_validacion == "puente":
        # usar columnas [1,3] -> B e índice 3
        colD = df_valid[3] if df_valid.shape[1] > 3 else pd.Series([None]*len(df_valid))
        for b, d in zip(colB, colD):
            idv = extraer_id_7_inicio_exacto(b)
            if idv is None:
                continue
            amt = parse_amount_safe(d)
            if amt is None:
                continue
            ids_list.append(idv)
            monto_list.append("{:.2f}".format(amt))
    else:
        # ACH: usar [1,2] y si [2] null usar [1,3]
        colC = df_valid[2] if df_valid.shape[1] > 2 else pd.Series([None]*len(df_valid))
        colD = df_valid[3] if df_valid.shape[1] > 3 else pd.Series([None]*len(df_valid))
        for b, c, d in zip(colB, colC, colD):
            idv = extraer_id_7_inicio_exacto(b)
            if idv is None:
                continue
            amt = parse_amount_safe(c)
            if amt is None:
                amt = parse_amount_safe(d)
            if amt is None:
                continue
            ids_list.append(idv)
            monto_list.append("{:.2f}".format(amt))

    df_validar_proc = pd.DataFrame({
        'LLAVE': [f"{i} | {m}" for i, m in zip(ids_list, monto_list)]
    })

# -----------------------
# Leer archivos de referencia (mantener rutas y pedir contraseña igual)
# - Para referencias usamos una lógica tolerante:
#   detectamos la columna con IDs (columna con mayor número de IDs válidos al inicio)
#   y preferimos columna 4 como monto, si no existe tratamos de detectar columna numérica
# -----------------------
referencia_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\referencia"
archivos_referencia = [f for f in os.listdir(referencia_dir) if f.lower().endswith(('.xlsx', '.xlsm', '.csv'))]
df_refs_list = []

for archivo in archivos_referencia:
    ruta_archivo = os.path.join(referencia_dir, archivo)
    try:
        if archivo.lower().endswith('.csv'):
            df_ref = pd.read_csv(
                ruta_archivo,
                header=None,
                dtype=str,
                sep='|',
                engine='python',
                on_bad_lines='skip'
            )
        else:
            with open(ruta_archivo, "rb") as f:
                office_file = msoffcrypto.OfficeFile(f)
                try:
                    enc_ref = office_file.is_encrypted()
                except Exception:
                    enc_ref = bool(password)
                if enc_ref:
                    try:
                        if password:
                            office_file.load_key(password=password)
                        decrypted_ref = io.BytesIO()
                        office_file.decrypt(decrypted_ref)
                        decrypted_ref.seek(0)
                        df_ref_original = pd.read_excel(decrypted_ref, engine="openpyxl", header=None)
                    except Exception:
                        df_ref_original = pd.read_excel(ruta_archivo, engine="openpyxl", header=None)
                else:
                    df_ref_original = pd.read_excel(ruta_archivo, engine="openpyxl", header=None)
            # si pocas columnas, la columna 0 probablemente contiene toda la línea con '|'
            if df_ref_original.shape[1] <= 4:
                df_ref = df_ref_original[0].astype(str).str.split('|', expand=True)
            else:
                df_ref = df_ref_original

        # detectar columna de ID: buscar entre las primeras columnas la que tenga más IDs válidos al inicio
        best_col = None
        best_count = 0
        max_check_col = min(4, df_ref.shape[1]-1)
        for col_idx in range(0, max_check_col+1):
            try:
                series_col = df_ref[col_idx].astype(str)
            except Exception:
                continue
            # contar cuántas filas tienen un leading exacto de 7 dígitos
            valid_count = series_col.apply(extraer_id_7_inicio_exacto).notna().sum()
            if valid_count > best_count:
                best_count = valid_count
                best_col = col_idx
        if best_col is None or best_count == 0:
            # no se encontró columna de IDs válida -> ignorar archivo
            continue

        # columna monto: preferir columna 4 si existe y tiene valores numéricos
        if 4 in df_ref.columns:
            col_amount = df_ref[4]
            # comprobar si parse_amount_safe devuelve algo
            if col_amount.apply(parse_amount_safe).notna().any():
                amount_col_idx = 4
            else:
                amount_col_idx = None
        else:
            amount_col_idx = None

        if amount_col_idx is None:
            # fallback: buscar alguna columna con valores numéricos (buscamos en 1..6)
            amount_col_idx = None
            for j in range(1, min(7, df_ref.shape[1])):
                serie = df_ref[j].apply(parse_amount_safe)
                if serie.notna().any():
                    amount_col_idx = j
                    break

        # si no hay columna monto válida, asumimos 0.00 (pero se puede cambiar)
        if amount_col_idx is None:
            monto_series = pd.Series(['0.00'] * len(df_ref), index=df_ref.index)
        else:
            monto_series = df_ref[amount_col_idx].apply(parse_amount_safe).map(lambda x: "{:.2f}".format(x) if x is not None else None)

        # extraer ids
        id_series = df_ref[best_col].astype(str).apply(extraer_id_7_inicio_exacto)

        # filtrar filas válidas (id no nulo y monto no nulo)
        df_ref_temp = pd.DataFrame({'ID': id_series, 'MONTO': monto_series})
        df_ref_temp = df_ref_temp[df_ref_temp['ID'].notna() & df_ref_temp['MONTO'].notna()].reset_index(drop=True)
        if df_ref_temp.empty:
            continue

        df_ref_proc = pd.DataFrame({'LLAVE': df_ref_temp['ID'] + " | " + df_ref_temp['MONTO']})
        df_refs_list.append(df_ref_proc)

    except Exception:
        # si falla un archivo, simplemente continuar con los demás
        continue

if not df_refs_list:
    raise ValueError("No se pudieron procesar archivos de referencia válidos.")

df_refs_concat = pd.concat(df_refs_list, ignore_index=True)

# -----------------------
# Comparar llaves: encontradas y no encontradas
# -----------------------
llaves_validas = set(df_validar_proc['LLAVE'])
llaves_referencia = set(df_refs_concat['LLAVE'])

llaves_encontradas = sorted(list(llaves_validas & llaves_referencia))
llaves_no_encontradas = sorted(list(llaves_validas - llaves_referencia))

# -----------------------
# Generar PDF: primero NO ENCONTRADAS, luego ENCONTRADAS (mismo PDF)
# -----------------------
pdf_name = simpledialog.askstring("Nombre del PDF", "Ingrese el nombre para el archivo PDF de salida (sin extensión):")
if not pdf_name:
    raise ValueError("Debe ingresar un nombre para el archivo PDF.")
ruta_pdf = f"{pdf_name}.pdf"

doc = SimpleDocTemplate(ruta_pdf, pagesize=letter)
elements = []
styles = getSampleStyleSheet()

# Tabla NO ENCONTRADAS
data_no = [[Paragraph("LLAVES NO ENCONTRADAS", styles['Heading4'])]]
for llave in llaves_no_encontradas:
    data_no.append([Paragraph(str(llave), styles['Normal'])])
tabla_no = Table(data_no, colWidths=[6.5 * inch])
tabla_no.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.red),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('VALIGN', (0, 0), (-1, -1), 'TOP')
]))
elements.append(tabla_no)
elements.append(Spacer(1, 0.3 * inch))

# Tabla ENCONTRADAS
data_si = [[Paragraph("LLAVES ENCONTRADAS", styles['Heading4'])]]
for llave in llaves_encontradas:
    data_si.append([Paragraph(str(llave), styles['Normal'])])
tabla_si = Table(data_si, colWidths=[6.5 * inch])
tabla_si.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.green),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('VALIGN', (0, 0), (-1, -1), 'TOP')
]))
elements.append(tabla_si)

doc.build(elements)

# Solo un mensaje final con la ruta del PDF (sin imprimir llaves)
print("PDF generado con llaves encontradas y no encontradas:", ruta_pdf)
