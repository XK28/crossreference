import os
import pandas as pd
import msoffcrypto
import io
import tkinter as tk
from tkinter import simpledialog
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch

# =======================
# Interfaz gráfica para selección de tipo de validación
# =======================
tipo_validacion = None

def seleccionar_tipo(tipo):
    global tipo_validacion
    tipo_validacion = tipo
    ventana.destroy()

ventana = tk.Tk()
ventana.title("Seleccionar tipo de validación")
ventana.geometry("300x120")
tk.Label(ventana, text="Seleccione el tipo de validación:").pack(pady=10)
tk.Button(ventana, text="ACH XPRESS", width=20, command=lambda: seleccionar_tipo("ach")).pack(pady=5)
tk.Button(ventana, text="Cuenta Puente", width=20, command=lambda: seleccionar_tipo("puente")).pack(pady=5)
ventana.mainloop()

# =======================
# Interfaz gráfica para contraseña
# =======================
password = simpledialog.askstring("Contraseña", "Ingrese la contraseña del archivo Excel (dejar vacío si no tiene):")

# =======================
# Función auxiliar: extraer ID = primeros 7 caracteres si todos son dígitos
# =======================
def extraer_id_7_inicio(s):
    s = str(s).strip()
    if len(s) < 7:
        return None
    primeros7 = s[:7]
    if primeros7.isdigit():
        return primeros7
    else:
        return None

# =======================
# Función auxiliar: elegir monto entre columna C o D
# =======================
def elegir_monto(c, d):
    try:
        mc = float(c)
        return mc
    except Exception:
        try:
            md = float(d)
            return md
        except Exception:
            return None

# =======================
# Leer validación
# =======================
validacion_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\validacion"
archivos_validacion = [f for f in os.listdir(validacion_dir) if f.lower().endswith(('.xlsx', '.xlsm', '.csv'))]
if not archivos_validacion:
    raise FileNotFoundError("No se encontró archivo de validación en la carpeta ./validacion")
ruta_validacion = os.path.join(validacion_dir, archivos_validacion[0])

if ruta_validacion.lower().endswith('.csv'):
    df_validar = pd.read_csv(
        ruta_validacion,
        header=None,
        dtype=str,
        sep='|',
        engine='python',
        on_bad_lines='skip'
    )
else:
    with open(ruta_validacion, "rb") as f:
        office_file = msoffcrypto.OfficeFile(f)
        try:
            enc = office_file.is_encrypted()
        except Exception:
            enc = bool(password)
        if enc:
            try:
                if password:
                    office_file.load_key(password=password)
                decrypted = io.BytesIO()
                office_file.decrypt(decrypted)
                decrypted.seek(0)
                df_validar = pd.read_excel(decrypted, engine="openpyxl", header=None)
            except Exception:
                df_validar = pd.read_excel(ruta_validacion, engine="openpyxl", header=None)
        else:
            df_validar = pd.read_excel(ruta_validacion, engine="openpyxl", header=None)

# =======================
# Procesar validación: fila 1+, ignorar filas si ID no válido o monto no válido
# =======================
if len(df_validar) > 1:
    df_valid = df_validar.iloc[1:].reset_index(drop=True)
else:
    df_valid = df_validar.copy()

# Columnas: B = índice 1, C = índice 2, D = índice 3
col_B = df_valid[1].astype(str)
col_C = df_valid[2] if df_valid.shape[1] > 2 else pd.Series([None]*len(df_valid))
col_D = df_valid[3] if df_valid.shape[1] > 3 else pd.Series([None]*len(df_valid))

ids = col_B.apply(extraer_id_7_inicio)
montos = [ elegir_monto(c, d) for c, d in zip(col_C, col_D) ]
montos_series = pd.Series(montos).map(lambda x: "{:.2f}".format(x) if x is not None else None)

# Filtrar filas válidas
df_valid_temp = pd.DataFrame({'ID': ids, 'MONTO': montos_series})
df_valid_temp = df_valid_temp[df_valid_temp['ID'].notna() & df_valid_temp['MONTO'].notna()].reset_index(drop=True)

# Crear llaves de validación
df_validar_proc = pd.DataFrame({'LLAVE': df_valid_temp['ID'] + " | " + df_valid_temp['MONTO']})

# =======================
# Leer referencias
# =======================
referencia_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\referencia"
archivos_referencia = [f for f in os.listdir(referencia_dir) if f.lower().endswith(('.xlsx', '.xlsm', '.csv'))]
df_refs_list = []

for archivo in archivos_referencia:
    ruta_archivo = os.path.join(referencia_dir, archivo)
    try:
        if archivo.lower().endswith('.csv'):
            df_ref = pd.read_csv(
                ruta_archivo,
                header=None,
                dtype=str,
                sep='|',
                engine='python',
                on_bad_lines='skip'
            )
        else:
            with open(ruta_archivo, "rb") as f:
                office_file = msoffcrypto.OfficeFile(f)
                try:
                    enc_ref = office_file.is_encrypted()
                except Exception:
                    enc_ref = bool(password)
                if enc_ref:
                    if password:
                        office_file.load_key(password=password)
                    decrypted_ref = io.BytesIO()
                    office_file.decrypt(decrypted_ref)
                    decrypted_ref.seek(0)
                    df_ref_original = pd.read_excel(decrypted_ref, engine="openpyxl", header=None)
                else:
                    df_ref_original = pd.read_excel(ruta_archivo, engine="openpyxl", header=None)

            if df_ref_original.shape[1] <= 4:
                df_ref = df_ref_original[0].astype(str).str.split('|', expand=True)
            else:
                df_ref = df_ref_original

        # Procesar referencia - extraer ID sólo si los primeros 7 caracteres de columna B son dígitos
        if 1 not in df_ref.columns:
            continue
        colB_ref = df_ref[1].astype(str)
        colC_ref = df_ref[2] if df_ref.shape[1] > 2 else pd.Series([None]*len(df_ref))
        colD_ref = df_ref[3] if df_ref.shape[1] > 3 else pd.Series([None]*len(df_ref))

        ids_ref = colB_ref.apply(extraer_id_7_inicio)
        montos_ref = [ elegir_monto(c, d) for c, d in zip(colC_ref, colD_ref) ]
        montos_ref_series = pd.Series(montos_ref).map(lambda x: "{:.2f}".format(x) if x is not None else None)

        df_ref_temp = pd.DataFrame({'ID': ids_ref, 'MONTO': montos_ref_series})
        df_ref_temp = df_ref_temp[df_ref_temp['ID'].notna() & df_ref_temp['MONTO'].notna()].reset_index(drop=True)

        df_ref_proc = pd.DataFrame({'LLAVE': df_ref_temp['ID'] + " | " + df_ref_temp['MONTO']})
        df_refs_list.append(df_ref_proc)

    except Exception:
        continue

if not df_refs_list:
    raise ValueError("No se pudieron procesar archivos de referencia válidos.")

df_refs_concat = pd.concat(df_refs_list, ignore_index=True)

# =======================
# Comparar llaves
# =======================
llaves_validas = set(df_validar_proc['LLAVE'])
llaves_referencia = set(df_refs_concat['LLAVE'])

llaves_encontradas = sorted(list(llaves_validas & llaves_referencia))
llaves_no_encontradas = sorted(list(llaves_validas - llaves_referencia))

# =======================
# Crear PDF con tablas NO encontradas y encontradas
# =======================
pdf_name = simpledialog.askstring("Nombre del PDF", "Ingrese el nombre para el archivo PDF de salida (sin extensión):")
if not pdf_name:
    raise ValueError("Debe ingresar un nombre para el archivo PDF.")
ruta_pdf = f"{pdf_name}.pdf"

doc = SimpleDocTemplate(ruta_pdf, pagesize=letter)
elements = []
styles = getSampleStyleSheet()

# Tabla NO ENCONTRADAS
data_no = [[Paragraph("LLAVES NO ENCONTRADAS", styles['Heading4'])]]
for llave in llaves_no_encontradas:
    data_no.append([Paragraph(str(llave), styles['Normal'])])

tabla_no = Table(data_no, colWidths=[6.5 * inch])
tabla_no.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.red),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('VALIGN', (0, 0), (-1, -1), 'TOP')
]))
elements.append(tabla_no)

elements.append(Spacer(1, 0.3 * inch))

# Tabla ENCONTRADAS
data_si = [[Paragraph("LLAVES ENCONTRADAS", styles['Heading4'])]]
for llave in llaves_encontradas:
    data_si.append([Paragraph(str(llave), styles['Normal'])])

tabla_si = Table(data_si, colWidths=[6.5 * inch])
tabla_si.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.green),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('VALIGN', (0, 0), (-1, -1), 'TOP')
]))
elements.append(tabla_si)

doc.build(elements)

print("PDF generado con llaves encontradas y no encontradas:", ruta_pdf)
