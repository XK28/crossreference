import os
import pandas as pd
import msoffcrypto
import io
import tkinter as tk
from tkinter import simpledialog
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch

# =======================
# Interfaz gráfica para selección de tipo de validación
# =======================
tipo_validacion = None

def seleccionar_tipo(tipo):
    global tipo_validacion
    tipo_validacion = tipo
    ventana.destroy()

ventana = tk.Tk()
ventana.title("Seleccionar tipo de validación")
ventana.geometry("300x120")
tk.Label(ventana, text="Seleccione el tipo de validación:").pack(pady=10)
tk.Button(ventana, text="ACH XPRESS", width=20, command=lambda: seleccionar_tipo("ach")).pack(pady=5)
tk.Button(ventana, text="Cuenta Puente", width=20, command=lambda: seleccionar_tipo("puente")).pack(pady=5)
ventana.mainloop()

# =======================
# Interfaz gráfica para contraseña
# =======================
password = simpledialog.askstring("Contraseña", "Ingrese la contraseña del archivo Excel (dejar vacío si no tiene):")

# =======================
# Función auxiliar: extraer ID de justamente 7 dígitos numéricos al inicio (columna B)
# =======================
def extraer_id_7(s):
    s = str(s)
    # Buscar los primeros 7 dígitos consecutivos en la cadena
    m = pd.Series(s).str.extract(r'(\d{7})')[0]
    if m.notna().all():
        # todos? queremos que la fila tenga un ID válido: al menos uno no-nulo
        return m.iloc[0]
    else:
        # Si no se encuentra un grupo de 7 dígitos, devolvemos None para ignorar
        return None

# =======================
# Leer archivo de validación
# =======================
validacion_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\validacion"
archivos_validacion = [f for f in os.listdir(validacion_dir) if f.lower().endswith(('.xlsx', '.xlsm', '.csv'))]
if not archivos_validacion:
    raise FileNotFoundError("No se encontró archivo de validación en la carpeta ./validacion")
ruta_validacion = os.path.join(validacion_dir, archivos_validacion[0])

# Cargar validación
if ruta_validacion.lower().endswith('.csv'):
    df_validar = pd.read_csv(
        ruta_validacion,
        header=None,
        dtype=str,
        sep='|',
        engine='python',
        on_bad_lines='skip'
    )
else:
    with open(ruta_validacion, "rb") as f:
        office_file = msoffcrypto.OfficeFile(f)
        try:
            enc = office_file.is_encrypted()
        except Exception:
            enc = bool(password)
        if enc:
            try:
                if password:
                    office_file.load_key(password=password)
                decrypted = io.BytesIO()
                office_file.decrypt(decrypted)
                decrypted.seek(0)
                df_validar = pd.read_excel(decrypted, engine="openpyxl", header=None)
            except Exception:
                df_validar = pd.read_excel(ruta_validacion, engine="openpyxl", header=None)
        else:
            df_validar = pd.read_excel(ruta_validacion, engine="openpyxl", header=None)

# =======================
# Procesar validación: iniciar desde fila 1, ignorar filas sin ID válido o monto válido
# =======================
# Empieza desde fila 1 (es decir, descartar fila 0 si lo deseas)
if len(df_validar) > 1:
    df_valid = df_validar.iloc[1:].reset_index(drop=True)
else:
    df_valid = df_validar.copy()

# La columna B corresponde al índice 1, columna C al índice 2, columna D al índice 3
col_B = df_valid[1].astype(str)
col_C = df_valid[2] if df_valid.shape[1] > 2 else pd.Series([None]*len(df_valid))
col_D = df_valid[3] if df_valid.shape[1] > 3 else pd.Series([None]*len(df_valid))

ids = col_B.apply(extraer_id_7)
# Monto: usar columna C si tiene dato (no null / no NaN / no vacía), sino columna D
def elegir_monto(c, d):
    try:
        # primero c
        mc = float(c)
        return mc
    except Exception:
        try:
            md = float(d)
            return md
        except Exception:
            return None

montos = [ elegir_monto(c, d) for c, d in zip(col_C, col_D) ]
montos_series = pd.Series(montos).map(lambda x: "{:.2f}".format(x) if x is not None else None)

# Ahora filtrar filas válidas: ID no None, monto no None
df_valid_temp = pd.DataFrame({
    'ID': ids,
    'MONTO': montos_series
})
df_valid_temp = df_valid_temp[df_valid_temp['ID'].notna() & df_valid_temp['MONTO'].notna()].reset_index(drop=True)

# Crear llave de validación
df_validar_proc = pd.DataFrame({
    'LLAVE': df_valid_temp['ID'] + " | " + df_valid_temp['MONTO']
})

# =======================
# Leer archivos de referencia
# =======================
referencia_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\referencia"
archivos_referencia = [f for f in os.listdir(referencia_dir) if f.lower().endswith(('.xlsx', '.xlsm', '.csv'))]
df_refs_list = []

for archivo in archivos_referencia:
    ruta_archivo = os.path.join(referencia_dir, archivo)
    try:
        if archivo.lower().endswith('.csv'):
            df_ref = pd.read_csv(
                ruta_archivo,
                header=None,
                dtype=str,
                sep='|',
                engine='python',
                on_bad_lines='skip'
            )
        else:
            with open(ruta_archivo, "rb") as f:
                office_file = msoffcrypto.OfficeFile(f)
                try:
                    enc_ref = office_file.is_encrypted()
                except Exception:
                    enc_ref = bool(password)
                if enc_ref:
                    if password:
                        office_file.load_key(password=password)
                    decrypted_ref = io.BytesIO()
                    office_file.decrypt(decrypted_ref)
                    decrypted_ref.seek(0)
                    df_ref_original = pd.read_excel(decrypted_ref, engine="openpyxl", header=None)
                else:
                    df_ref_original = pd.read_excel(ruta_archivo, engine="openpyxl", header=None)

            if df_ref_original.shape[1] <= 4:
                df_ref = df_ref_original[0].astype(str).str.split('|', expand=True)
            else:
                df_ref = df_ref_original

        # Verificar que columna B y columna C o D existan: B → índice 1, C → 2, D → 3
        # Extraer ID igual: primeros 7 dígitos de columna B
        if 1 not in df_ref.columns:
            continue
        colB_ref = df_ref[1].astype(str)
        # Columna C o D montos
        colC_ref = df_ref[2] if df_ref.shape[1] > 2 else pd.Series([None]*len(df_ref))
        colD_ref = df_ref[3] if df_ref.shape[1] > 3 else pd.Series([None]*len(df_ref))

        ids_ref = colB_ref.apply(extraer_id_7)
        montos_ref = [ elegir_monto(c, d) for c, d in zip(colC_ref, colD_ref) ]
        montos_ref_series = pd.Series(montos_ref).map(lambda x: "{:.2f}".format(x) if x is not None else None)

        # Filtrar filas válidas
        df_ref_temp = pd.DataFrame({
            'ID': ids_ref,
            'MONTO': montos_ref_series
        })
        df_ref_temp = df_ref_temp[df_ref_temp['ID'].notna() & df_ref_temp['MONTO'].notna()].reset_index(drop=True)

        # Crear llave de referencia
        df_ref_proc = pd.DataFrame({
            'LLAVE': df_ref_temp['ID'] + " | " + df_ref_temp['MONTO']
        })

        df_refs_list.append(df_ref_proc)

    except Exception:
        continue

if not df_refs_list:
    raise ValueError("No se pudieron procesar archivos de referencia válidos.")

df_refs_concat = pd.concat(df_refs_list, ignore_index=True)

# =======================
# Comparar llaves: encontradas y no encontradas
# =======================
# Lista de llaves validas
llaves_validas = set(df_validar_proc['LLAVE'])
llaves_referencia = set(df_refs_concat['LLAVE'])

# Llaves encontradas = intersección
llaves_encontradas = sorted(list(llaves_validas & llaves_referencia))
# Llaves no encontradas = las de validación que no están en referencia
llaves_no_encontradas = sorted(list(llaves_validas - llaves_referencia))

# =======================
# Interfaz gráfica para nombre del PDF
# =======================
pdf_name = simpledialog.askstring("Nombre del PDF", "Ingrese el nombre para el archivo PDF de salida (sin extensión):")
if not pdf_name:
    raise ValueError("Debe ingresar un nombre para el archivo PDF.")
ruta_pdf = f"{pdf_name}.pdf"

# =======================
# Crear PDF con llaves NO encontradas primero y luego llaves encontradas
# =======================
doc = SimpleDocTemplate(ruta_pdf, pagesize=letter)
elements = []
styles = getSampleStyleSheet()

# Tabla de encabezado: NO ENCONTRADAS
data_no = [[Paragraph("LLAVES NO ENCONTRADAS", styles['Heading4'])]]
for llave in llaves_no_encontradas:
    data_no.append([Paragraph(str(llave), styles['Normal'])])

tabla_no = Table(data_no, colWidths=[6.5 * inch])
tabla_no.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.red),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('VALIGN', (0, 0), (-1, -1), 'TOP')
]))

elements.append(tabla_no)

# Agregar espacio entre tablas
from reportlab.platypus import Spacer
elements.append( Spacer(1, 0.3 * inch) )

# Tabla de LLAVES ENCONTRADAS
data_si = [[Paragraph("LLAVES ENCONTRADAS", styles['Heading4'])]]
for llave in llaves_encontradas:
    data_si.append([Paragraph(str(llave), styles['Normal'])])

tabla_si = Table(data_si, colWidths=[6.5 * inch])
tabla_si.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.green),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('VALIGN', (0, 0), (-1, -1), 'TOP')
]))

elements.append(tabla_si)

# Construir pdf
doc.build(elements)

print("PDF generado con llaves no encontradas y encontradas:", ruta_pdf)
