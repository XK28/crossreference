import pandas as pd
import os
import msoffcrypto
import io
import tkinter as tk
from tkinter import simpledialog
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet
from reportlab.lib.units import inch

# =======================
# Interfaz gráfica para selección de tipo de validación
# =======================
tipo_validacion = None

def seleccionar_tipo(tipo):
    global tipo_validacion
    tipo_validacion = tipo
    ventana.destroy()

ventana = tk.Tk()
ventana.title("Seleccionar tipo de validación")
ventana.geometry("300x120")
tk.Label(ventana, text="Seleccione el tipo de validación:").pack(pady=10)
tk.Button(ventana, text="ACH XPRESS", width=20, command=lambda: seleccionar_tipo("ach")).pack(pady=5)
tk.Button(ventana, text="Cuenta Puente", width=20, command=lambda: seleccionar_tipo("puente")).pack(pady=5)
ventana.mainloop()

# =======================
# Interfaz gráfica para contraseña
# =======================
password = simpledialog.askstring("Contraseña", "Ingrese la contraseña del archivo Excel (dejar vacío si no tiene):")

# =======================
# Función auxiliar: extraer ID de 7 dígitos
# =======================
def extraer_id(s):
    s = str(s)
    # Regex correcto: \d{7}
    m = pd.Series(s).str.extract(r'(\d{7})')[0]
    if pd.isna(m).all():
        return None
    else:
        # tomar el primer no nulo
        return m.iloc[0]

# =======================
# Leer archivo de validación
# =======================
validacion_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\validacion"
archivos_validacion = [f for f in os.listdir(validacion_dir) if f.endswith(('.xlsx', '.xlsm', '.csv'))]
if not archivos_validacion:
    raise FileNotFoundError("No se encontró archivo de validación en la carpeta ./validacion")
ruta_validacion = os.path.join(validacion_dir, archivos_validacion[0])

# Cargar validación
if ruta_validacion.lower().endswith('.csv'):
    # CSV: separar por '|' si hay, o si no tienes campo cargo exacto, asumir columna con cargo
    df_validar = pd.read_csv(ruta_validacion, header=None, skiprows=8, dtype=str, sep='|', engine='python', on_bad_lines='skip')
    # A partir del CSV, cargo numérico se espera en la columna 4 (índice 4)
else:
    # Excel o Excel protegido
    try:
        with open(ruta_validacion, "rb") as f:
            office_file = msoffcrypto.OfficeFile(f)
            if password:
                office_file.load_key(password=password)
            # si no hay password, puede pasar None o fallar
            decrypted = io.BytesIO()
            office_file.decrypt(decrypted)
            decrypted.seek(0)
            df_validar = pd.read_excel(decrypted, engine="openpyxl", header=None, skiprows=8)
    except Exception as e:
        # Fallback si no está cifrado o password incorrecto
        # Intentar abrir sin contraseña
        df_validar = pd.read_excel(ruta_validacion, engine="openpyxl", header=None, skiprows=8)

# Selección de columnas segun tipo_validacion
if tipo_validacion == "puente":
    # supongo que la COLUMNA “CARGO” en puente es índice 3; verificar con tus datos
    if df_validar.shape[1] <= 3:
        raise ValueError("El archivo de validación tipo puente no tiene suficientes columnas.")
    col_id_valid = df_validar[1]
    col_cargo_valid = df_validar[3]
else:  # tipo “ach”
    if df_validar.shape[1] <= 2:
        raise ValueError("El archivo de validación tipo ACH no tiene suficientes columnas.")
    col_id_valid = df_validar[1]
    col_cargo_valid = df_validar[2]

# Extraer ID
IDs_valid = col_id_valid.astype(str).apply(lambda s: extraer_id(s))
# Procesar CARGO
cargos_valid = pd.to_numeric(col_cargo_valid, errors='coerce').fillna(0).map('{:.2f}'.format)

df_validar_proc = pd.DataFrame({
    'LLAVE': IDs_valid + " | " + cargos_valid
})

# =======================
# Leer archivos de referencia
# =======================
referencia_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\referencia"
archivos_referencia = [f for f in os.listdir(referencia_dir) if f.endswith(('.xlsx', '.xlsm', '.csv'))]
df_refs_list = []

for archivo in archivos_referencia:
    ruta_archivo = os.path.join(referencia_dir, archivo)
    try:
        if archivo.lower().endswith('.csv'):
            # Leer CSV con sep='|'
            df_ref = pd.read_csv(ruta_archivo, header=None, dtype=str, sep='|', engine='python', on_bad_lines='skip')
        else:
            # Excel
            with open(ruta_archivo, "rb") as f:
                office_file = msoffcrypto.OfficeFile(f)
                if password:
                    office_file.load_key(password=password)
                decrypted = io.BytesIO()
                office_file.decrypt(decrypted)
                decrypted.seek(0)
                df_ref = pd.read_excel(decrypted, engine="openpyxl", header=None)
    except Exception as e:
        # si no se puede desencriptar o leer, intentar sin password
        try:
            df_ref = pd.read_excel(ruta_archivo, engine="openpyxl", header=None)
        except Exception as e2:
            print(f"Error procesando referencia {archivo}: {e2}")
            continue

    # Procesar df_ref para extraer ID y campo cargo (campo índice 4 en CSV/ después del split)
    # Asegurar que df_ref tiene al menos 5 columnas
    if df_ref.shape[1] <= 4:
        # No tiene columna 4, lo ignoramos
        print(f"Referencia {archivo} ignorada por no tener suficientes columnas")
        continue

    col_id_ref = df_ref[0].astype(str).apply(lambda s: extraer_id(s))
    col_cargo_ref = pd.to_numeric(df_ref[4], errors='coerce').fillna(0).map('{:.2f}'.format)

    df_ref_proc = pd.DataFrame({
        'LLAVE': col_id_ref + " | " + col_cargo_ref
    })

    df_refs_list.append(df_ref_proc)

if not df_refs_list:
    raise ValueError("No se pudieron procesar archivos de referencia válidos.")

df_refs_concat = pd.concat(df_refs_list, ignore_index=True)

# =======================
# Comparar llaves
# =======================
llaves_no_encontradas = df_validar_proc[~df_validar_proc['LLAVE'].isin(df_refs_concat['LLAVE'])]

# =======================
# Interfaz gráfica para nombre del PDF
# =======================
pdf_name = simpledialog.askstring("Nombre del PDF", "Ingrese el nombre para el archivo PDF de salida (sin extensión):")
if not pdf_name:
    raise ValueError("Debe ingresar un nombre para el archivo PDF.")
ruta_pdf = f"{pdf_name}.pdf"

# =======================
# Crear PDF con llaves no encontradas
# =======================
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph
from reportlab.lib.styles import getSampleStyleSheet

doc = SimpleDocTemplate(ruta_pdf, pagesize=letter)
elements = []
styles = getSampleStyleSheet()

data = [[Paragraph("LLAVES NO ENCONTRADAS", styles['Heading4'])]]
for llave in llaves_no_encontradas['LLAVE']:
    data.append([Paragraph(str(llave), styles['Normal'])])

tabla = Table(data, colWidths=[6.5 * inch])
tabla.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.skyblue),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('VALIGN', (0, 0), (-1, -1), 'TOP')
]))
elements.append(tabla)
doc.build(elements)

print("PDF generado con llaves no encontradas:", ruta_pdf)
