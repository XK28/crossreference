import os
import re
import io
import subprocess
import pandas as pd
import msoffcrypto
import tkinter as tk
from tkinter import simpledialog, messagebox
from dateutil.parser import parse, ParserError
from reportlab.lib.pagesizes import letter
from reportlab.platypus import (
    SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
)
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch

# ----------------------------
# Función para calcular SHA256 usando certutil (Windows)
# ----------------------------
def calcular_sha256_con_certutil(ruta_archivo):
    try:
        cmd = ["certutil", "-hashfile", ruta_archivo, "SHA256"]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print("Error al ejecutar certutil:", e)
        return None
    except FileNotFoundError:
        print("certutil no disponible en el sistema.")
        return None

# ----------------------------
# Funciones auxiliares: detectar fecha, extraer dígitos iniciales, parsear monto
# ----------------------------
def es_fecha(s):
    if s is None:
        return False
    s = str(s).strip()
    if s == "":
        return False
    try:
        _ = parse(s, fuzzy=False)
        return True
    except (ParserError, ValueError):
        return False

def extraer_id_inicio_numeros(s):
    if s is None:
        return None
    s = str(s).strip()
    m = re.match(r'^(\d+)', s)
    if not m:
        return None
    return m.group(1)

def parse_amount_safe(x):
    if x is None or (isinstance(x, float) and pd.isna(x)):
        return None
    s = str(x).strip()
    if s == "":
        return None
    s = s.replace(",", "")
    s = re.sub(r'[^\d.\-]', '', s)
    try:
        return float(s)
    except:
        return None

# -----------------------
# Login de usuario
# -----------------------
login_window = tk.Tk()
login_window.withdraw()  # Oculta la ventana principal

# Diccionario de usuarios válidos
usuarios_validos = {
    'madeleo': 'Security1st',
    'itejada': 'goadmiN2'  # Segundo usuario con su contraseña
}

usuario = simpledialog.askstring("Usuario", "Ingrese su nombre de usuario:")
password = simpledialog.askstring("Contraseña", "Ingrese su contraseña:", show='*')

# Verifica si el usuario y la contraseña son válidos
if usuario not in usuarios_validos or usuarios_validos[usuario] != password:
    messagebox.showerror("Error de autenticación", "Usuario o contraseña incorrectos.")
    login_window.destroy()
    exit()

login_window.destroy()

# ----------------------------
# Interfaz gráfica para elegir tipo de validación
# ----------------------------
tipo_validacion = None
def seleccionar_tipo(tipo):
    global tipo_validacion
    tipo_validacion = tipo
    ventana.destroy()

ventana = tk.Tk()
ventana.title("Seleccionar tipo de validación")
ventana.geometry("300x120")
tk.Label(ventana, text="Seleccione tipo de validación:").pack(pady=10)
tk.Button(ventana, text="ACH XPRESS", width=20, command=lambda: seleccionar_tipo("ach")).pack(pady=5)
tk.Button(ventana, text="Cuenta Puente", width=20, command=lambda: seleccionar_tipo("puente")).pack(pady=5)
ventana.mainloop()

# ----------------------------
# Pedir contraseña para archivos Excel protegidos
# ----------------------------
password = simpledialog.askstring("Contraseña", "Ingrese la contraseña del archivo Excel (dejar vacío si no tiene):")

# ----------------------------
# Rutas definidas
# ----------------------------
validacion_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\validacion"
referencia_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\referencia"

# ----------------------------
# Selección del archivo de validación
# ----------------------------
archivos_validacion = [
    f for f in os.listdir(validacion_dir)
    if f.lower().endswith(('.xlsx', '.xlsm', '.csv'))
]
if not archivos_validacion:
    raise FileNotFoundError("No se encontró archivo de validación.")
ruta_validacion = os.path.join(validacion_dir, archivos_validacion[0])

# ----------------------------
# Leer archivo de validación
# ----------------------------
if ruta_validacion.lower().endswith('.csv'):
    df_validar = pd.read_csv(
        ruta_validacion,
        header=None,
        dtype=str,
        sep='|',
        engine='python',
        on_bad_lines='skip'
    )
else:
    with open(ruta_validacion, "rb") as f:
        office = msoffcrypto.OfficeFile(f)
        try:
            encrypted = office.is_encrypted()
        except:
            encrypted = bool(password)
        if encrypted:
            if password:
                office.load_key(password=password)
            dec = io.BytesIO()
            office.decrypt(dec)
            dec.seek(0)
            df_validar = pd.read_excel(dec, engine="openpyxl", header=None)
        else:
            df_validar = pd.read_excel(ruta_validacion, engine="openpyxl", header=None)

# ----------------------------
# Generar llaves de validación + excepciones
# ----------------------------
if len(df_validar) > 1:
    df_valid = df_validar.iloc[1:].reset_index(drop=True)
else:
    df_valid = df_validar.copy()

# Filtrar filas donde B es vacía o nula
if 1 in df_valid.columns:
    df_valid = df_valid[df_valid[1].notna() & (df_valid[1].astype(str).str.strip() != "")].reset_index(drop=True)

colB = df_valid[1].astype(str) if df_valid.shape[1] > 1 else pd.Series([None]*len(df_valid))
colC = df_valid[2] if df_valid.shape[1] > 2 else pd.Series([None]*len(df_valid))
colD = df_valid[3] if df_valid.shape[1] > 3 else pd.Series([None]*len(df_valid))

valid_llaves = []       # lista de (llave, monto)
excepciones = []        # lista de (fila_indice, valor_B, motivo)

for idx, (b, c, d) in enumerate(zip(colB, colC, colD), start=1):
    b_str = str(b).strip()
    if b_str == "":
        continue
    if es_fecha(b_str):
        continue
    # Si no inicia con dígito, ignorar por completo
    if not b_str[0].isdigit():
        continue

    # Extraer secuencia inicial de dígitos
    id_seq = extraer_id_inicio_numeros(b_str)
    if id_seq is None:
        excepciones.append((idx, b_str, "No extrajo dígitos iniciales"))
        continue

    # Si la secuencia inicial tiene longitud < 7 → excepción
    if len(id_seq) < 7:
        excepciones.append((idx, b_str, f"Secuencia inicial '{id_seq}' < 7 dígitos"))
        continue

    # Secuencia válida (≥ 7 dígitos), crear llave con monto
    amt_c = parse_amount_safe(c)
    if amt_c is not None:
        llave = f"{id_seq} | {amt_c:.2f}"
        valid_llaves.append((llave, amt_c))
    else:
        amt_d = parse_amount_safe(d)
        if amt_d is not None:
            llave = f"{id_seq} | {amt_d:.2f}"
            valid_llaves.append((llave, amt_d))
        else:
            # Sin monto válido en C ni D → ignorar (no es excepción de B)
            continue

llaves_validas = set(lk for (lk, _) in valid_llaves)

# ----------------------------
# Leer los documentos en referencia: calcular hash + extraer llaves
# ----------------------------
ref_llaves = set()
hashes_referencia = {}

for ar in os.listdir(referencia_dir):
    if not ar.lower().endswith(('.xlsx', '.xlsm', '.csv')):
        continue
    ruta_ar = os.path.join(referencia_dir, ar)
    h = calcular_sha256_con_certutil(ruta_ar)
    hashes_referencia[ar] = h

    try:
        if ar.lower().endswith('.csv'):
            df_ref = pd.read_csv(
                ruta_ar,
                header=None,
                dtype=str,
                sep='|',
                engine='python',
                on_bad_lines='skip'
            )
        else:
            with open(ruta_ar, "rb") as f:
                office = msoffcrypto.OfficeFile(f)
                try:
                    enc = office.is_encrypted()
                except:
                    enc = False
                if enc:
                    if password:
                        office.load_key(password=password)
                    dec = io.BytesIO()
                    office.decrypt(dec)
                    dec.seek(0)
                    df_ref = pd.read_excel(dec, engine="openpyxl", header=None)
                else:
                    df_ref = pd.read_excel(ruta_ar, engine="openpyxl", header=None)

        if df_ref.shape[1] == 1:
            df_split = df_ref[0].astype(str).str.split("|", expand=True)
        else:
            df_split = df_ref

        for i, row in df_split.iterrows():
            val0 = str(row.iloc[0]).strip()
            if val0 == "":
                continue
            if es_fecha(val0):
                continue
            if not val0[0].isdigit():
                continue
            id_seq_ref = extraer_id_inicio_numeros(val0)
            if id_seq_ref is None or len(id_seq_ref) < 7:
                continue
            monto_ref = None
            for j in range(1, min(df_split.shape[1], 7)):
                cand = parse_amount_safe(row.iloc[j])
                if cand is not None:
                    monto_ref = cand
                    break
            if monto_ref is None:
                continue
            llave_ref = f"{id_seq_ref} | {monto_ref:.2f}"
            ref_llaves.add(llave_ref)
    except Exception as e:
        print(f"Error procesando referencia {ar}: {e}")
        continue

# ----------------------------
# Comparar llaves
# ----------------------------
llaves_encontradas = sorted(lk for lk in llaves_validas if lk in ref_llaves)
llaves_no_encontradas = sorted(lk for lk in llaves_validas if lk not in ref_llaves)

# ----------------------------
# Sumar montos de llaves encontradas y no encontradas
# ----------------------------
found_montos = [m for (lk, m) in valid_llaves if lk in ref_llaves]
sum_found = sum(found_montos)
cnt_found = len(found_montos)

no_found_montos = [m for (lk, m) in valid_llaves if lk not in ref_llaves]
sum_no_found = sum(no_found_montos)
cnt_no_found = len(no_found_montos)

# ----------------------------
# Generar PDF con formatos de tablas y totales
# ----------------------------
pdf_name = simpledialog.askstring("Nombre del PDF", "Ingrese nombre para el archivo PDF (sin extensión):")
if not pdf_name:
    raise ValueError("Debe ingresar nombre para PDF")

carpeta_salida = r"C:\Users\katejada\Desktop\Codigos y .Exe\ACH\resultados"
if not os.path.exists(carpeta_salida):
    os.makedirs(carpeta_salida, exist_ok=True)
ruta_pdf = os.path.join(carpeta_salida, f"{pdf_name}.pdf")

doc = SimpleDocTemplate(ruta_pdf, pagesize=letter)
elements = []
styles = getSampleStyleSheet()

# Agregar hashes de referencia
elements.append(Paragraph("Hashes de archivos de referencia:", styles["Heading4"]))
for ar, h in hashes_referencia.items():
    elements.append(Paragraph(f"{ar}: {h}", styles["Normal"]))
elements.append(Spacer(1, 0.2 * inch))

# Agregar resumen + totales
style_res = ParagraphStyle("Resumen", parent=styles["Normal"], leading=14)
texto_res = (
    f"Total llaves válidas generadas: {len(llaves_validas)}<br/>"
    f"Encontradas: {cnt_found} , suma montos: {sum_found:.2f}<br/>"
    f"No encontradas: {cnt_no_found} , suma montos: {sum_no_found:.2f}<br/>"
    f"**Total general (Encontradas + No Encontradas): {(sum_found + sum_no_found):.2f}**"
)
elements.append(Paragraph(texto_res, style_res))
elements.append(Spacer(1, 0.2 * inch))

# Excepciones
if excepciones:
    elements.append(Paragraph("Excepciones (solo B valida pero longitud insuficiente):", styles["Heading4"]))
    data_exc = [["Fila", "Valor B", "Motivo"]]
    for (fila, valb, mot) in excepciones:
        data_exc.append([str(fila), Paragraph(str(valb), styles["Normal"]), Paragraph(mot, styles["Normal"])])
    tabla_exc = Table(data_exc, colWidths=[1.0*inch, 3.5*inch, 2.0*inch])
    tabla_exc.setStyle(TableStyle([
        ('BACKGROUND', (0,0), (-1,0), colors.grey),
        ('TEXTCOLOR', (0,0), (-1,0), colors.whitesmoke),
        ('ALIGN', (0,0), (-1,-1), 'LEFT'),
        ('GRID', (0,0), (-1,-1), 0.5, colors.black),
        ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold'),
        ('VALIGN', (0,0), (-1,-1), 'TOP')
    ]))
    elements.append(tabla_exc)
    elements.append(Spacer(1, 0.3 * inch))

# Tabla “NO ENCONTRADAS” con título rojo
data_no = [[Paragraph("LLAVES NO ENCONTRADAS", styles["Heading4"])]]
for lk in llaves_no_encontradas:
    data_no.append([Paragraph(str(lk), styles["Normal"])])
tabla_no = Table(data_no, colWidths=[6.5 * inch])
tabla_no.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.red),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('VALIGN', (0, 0), (-1, -1), 'TOP')
]))
elements.append(tabla_no)
elements.append(Spacer(1, 0.3 * inch))

# Tabla “ENCONTRADAS” con título verde
data_si = [[Paragraph("LLAVES ENCONTRADAS", styles["Heading4"])]]
for lk in llaves_encontradas:
    data_si.append([Paragraph(str(lk), styles["Normal"])])
tabla_si = Table(data_si, colWidths=[6.5 * inch])
tabla_si.setStyle(TableStyle([
    ('BACKGROUND', (0, 0), (-1, 0), colors.green),
    ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
    ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
    ('GRID', (0, 0), (-1, -1), 0.5, colors.black),
    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
    ('VALIGN', (0, 0), (-1, -1), 'TOP')
]))
elements.append(tabla_si)

doc.build(elements)

print("PDF generado:", ruta_pdf)

