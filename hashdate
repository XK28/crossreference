import os
import re
import io
import subprocess
import pandas as pd
import msoffcrypto
import tkinter as tk
from tkinter import simpledialog
from reportlab.lib.pagesizes import letter
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer
from reportlab.lib import colors
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch

# ----------------------------
# Función para calcular SHA256 usando certutil (Windows)
# ----------------------------
def calcular_sha256_con_certutil(ruta_archivo):
    try:
        cmd = ["certutil", "-hashfile", ruta_archivo, "SHA256"]
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        print("Error al ejecutar certutil:", e)
        return None
    except FileNotFoundError:
        print("certutil no disponible en sistema.")
        return None

# ----------------------------
# Funciones auxiliares para detectar fecha, extraer dígitos iniciales, parsear montos
# ----------------------------
from dateutil.parser import parse, ParserError

def es_fecha(s):
    """
    Retorna True si la cadena s puede interpretarse como fecha (con parseo estricto).
    """
    if s is None:
        return False
    s = str(s).strip()
    if s == "":
        return False
    try:
        _ = parse(s, fuzzy=False)
        return True
    except (ParserError, ValueError):
        return False

def extraer_id_inicio_numeros(s):
    """
    Retorna la secuencia de dígitos iniciales de la cadena s (uno o más),
    o None si no empieza con dígito.
    """
    if s is None:
        return None
    s = str(s).strip()
    m = re.match(r'^(\d+)', s)
    if not m:
        return None
    return m.group(1)

def parse_amount_safe(x):
    """
    Convierte x a float si es posible, limpiando caracteres no numéricos.
    Retorna None si no es convertible.
    """
    if x is None or (isinstance(x, float) and pd.isna(x)):
        return None
    s = str(x).strip()
    if s == "":
        return None
    s = s.replace(",", "")
    s = re.sub(r'[^\d.\-]', '', s)
    try:
        return float(s)
    except:
        return None

# ----------------------------
# Interfaz gráfica para elegir tipo validación
# ----------------------------
tipo_validacion = None

def seleccionar_tipo(tipo):
    global tipo_validacion
    tipo_validacion = tipo
    ventana.destroy()

ventana = tk.Tk()
ventana.title("Seleccionar tipo de validación")
ventana.geometry("300x120")
tk.Label(ventana, text="Seleccione el tipo de validación:").pack(pady=10)
tk.Button(ventana, text="ACH XPRESS", width=20, command=lambda: seleccionar_tipo("ach")).pack(pady=5)
tk.Button(ventana, text="Cuenta Puente", width=20, command=lambda: seleccionar_tipo("puente")).pack(pady=5)
ventana.mainloop()

# ----------------------------
# Pedir contraseña para Excel protegidos
# ----------------------------
password = simpledialog.askstring("Contraseña", "Ingrese la contraseña del archivo Excel (dejar vacío si no tiene):")

# ----------------------------
# Rutas fijas
# ----------------------------
validacion_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\validacion"
referencia_dir = r"C:\\Users\\katejada\\Desktop\\Codigos y .Exe\\ACH\\referencia"

# ----------------------------
# Selección del archivo de validación
# ----------------------------
archivos_validacion = [
    f for f in os.listdir(validacion_dir)
    if f.lower().endswith(('.xlsx', '.xlsm', '.csv'))
]
if not archivos_validacion:
    raise FileNotFoundError("No se encontró archivo de validación.")
ruta_validacion = os.path.join(validacion_dir, archivos_validacion[0])

# ----------------------------
# Leer archivo de validación
# ----------------------------
if ruta_validacion.lower().endswith('.csv'):
    df_validar = pd.read_csv(
        ruta_validacion,
        header=None,
        dtype=str,
        sep='|',
        engine='python',
        on_bad_lines='skip'
    )
else:
    with open(ruta_validacion, "rb") as f:
        office = msoffcrypto.OfficeFile(f)
        try:
            encrypted = office.is_encrypted()
        except:
            encrypted = bool(password)
        if encrypted:
            if password:
                office.load_key(password=password)
            dec = io.BytesIO()
            office.decrypt(dec)
            dec.seek(0)
            df_validar = pd.read_excel(dec, engine="openpyxl", header=None)
        else:
            df_validar = pd.read_excel(ruta_validacion, engine="openpyxl", header=None)

# ----------------------------
# Generar llaves del archivo de validación + excepciones
# ----------------------------
if len(df_validar) > 1:
    df_valid = df_validar.iloc[1:].reset_index(drop=True)
else:
    df_valid = df_validar.copy()

# Filtrar filas con B vacío o nulo
if 1 in df_valid.columns:
    df_valid = df_valid[df_valid[1].notna() & (df_valid[1].astype(str).str.strip() != "")].reset_index(drop=True)

colB = df_valid[1].astype(str) if df_valid.shape[1] > 1 else pd.Series([None]*len(df_valid))
colC = df_valid[2] if df_valid.shape[1] > 2 else pd.Series([None]*len(df_valid))
colD = df_valid[3] if df_valid.shape[1] > 3 else pd.Series([None]*len(df_valid))

valid_llaves = []   # lista de (llave, monto)
excepciones = []    # lista de (fila_indice, valor_B, motivo)

# Primero, (opcional) calcular hashes de referencia para usarse luego
hashes_referencia = {}

# Generar llaves para validación
for idx, (b, c, d) in enumerate(zip(colB, colC, colD), start=1):
    b_str = str(b).strip()
    if b_str == "":
        continue

    # Si b_str es fecha, ignorar completamente
    if es_fecha(b_str):
        continue

    # Intentar extraer secuencia inicial de dígitos
    id_seq = extraer_id_inicio_numeros(b_str)
    if id_seq is None:
        # no empieza con dígito
        excepciones.append((idx, b_str, "No inicia con dígito"))
        continue

    # Si la secuencia de dígitos iniciales es menor de 7 → excepción
    if len(id_seq) < 7:
        excepciones.append((idx, b_str, f"Secuencia dígitos iniciales '{id_seq}' con longitud <7"))
        continue

    # Si tiene ≥7 dígitos iniciales, lo aceptamos como ID
    # Luego extraemos monto C preferido o fallback D
    amt_c = parse_amount_safe(c)
    if amt_c is not None:
        llave = f"{id_seq} | {amt_c:.2f}"
        valid_llaves.append((llave, amt_c))
    else:
        amt_d = parse_amount_safe(d)
        if amt_d is not None:
            llave = f"{id_seq} | {amt_d:.2f}"
            valid_llaves.append((llave, amt_d))
        else:
            # Sin monto válido en C ni en D: no generamos llave
            # Podrías, si lo deseas, registrar como excepción “sin monto”
            continue

llaves_validas = set([lk for (lk, _) in valid_llaves])

# ----------------------------
# Leer documentos de referencia: calcular hash + extraer llaves
# ----------------------------
ref_llaves = set()

for ar in os.listdir(referencia_dir):
    if not ar.lower().endswith(('.xlsx', '.xlsm', '.csv')):
        continue
    ruta_ar = os.path.join(referencia_dir, ar)
    h = calcular_sha256_con_certutil(ruta_ar)
    hashes_referencia[ar] = h

    try:
        if ar.lower().endswith('.csv'):
            df_ref = pd.read_csv(
                ruta_ar,
                header=None,
                dtype=str,
                sep='|',
                engine='python',
                on_bad_lines='skip'
            )
        else:
            with open(ruta_ar, "rb") as f:
                office = msoffcrypto.OfficeFile(f)
                try:
                    enc = office.is_encrypted()
                except:
                    enc = False
                if enc:
                    if password:
                        office.load_key(password=password)
                    dec = io.BytesIO()
                    office.decrypt(dec)
                    dec.seek(0)
                    df_ref = pd.read_excel(dec, engine="openpyxl", header=None)
                else:
                    df_ref = pd.read_excel(ruta_ar, engine="openpyxl", header=None)

        if df_ref.shape[1] == 1:
            df_split = df_ref[0].astype(str).str.split("|", expand=True)
        else:
            df_split = df_ref

        # Para cada fila en referencia, extraer llave usando la misma regla
        for i, row in df_split.iterrows():
            val0 = str(row.iloc[0]).strip()
            if val0 == "":
                continue
            if es_fecha(val0):
                continue
            id_seq_ref = extraer_id_inicio_numeros(val0)
            if id_seq_ref is None:
                continue
            if len(id_seq_ref) < 7:
                continue
            # buscar monto en alguna columna
            monto_ref = None
            for j in range(1, min(df_split.shape[1], 7)):
                cand = parse_amount_safe(row.iloc[j])
                if cand is not None:
                    monto_ref = cand
                    break
            if monto_ref is None:
                continue
            llave_ref = f"{id_seq_ref} | {monto_ref:.2f}"
            ref_llaves.add(llave_ref)
    except Exception as e:
        print(f"Error procesando referencia {ar}: {e}")
        continue

# ----------------------------
# Comparar llaves
# ----------------------------
llaves_encontradas = sorted(lk for lk in llaves_validas if lk in ref_llaves)
llaves_no_encontradas = sorted(lk for lk in llaves_validas if lk not in ref_llaves)

# ----------------------------
# Resúmenes de montos
# ----------------------------
found_montos = [m for (lk, m) in valid_llaves if lk in ref_llaves]
sum_found = sum(found_montos)
cnt_found = len(found_montos)

no_found_montos = [m for (lk, m) in valid_llaves if lk not in ref_llaves]
sum_no_found = sum(no_found_montos)
cnt_no_found = len(no_found_montos)

# ----------------------------
# Generar PDF con todo
# ----------------------------
pdf_name = simpledialog.askstring("Nombre del PDF", "Ingrese nombre del archivo PDF (sin extensión):")
if not pdf_name:
    raise ValueError("Debe ingresar nombre para el PDF")

carpeta_salida = r"\\ntappama01-c01\Herramienta Usuario Final en Ejecucion\REVISION XPRESS"
if not os.path.exists(carpeta_salida):
    os.makedirs(carpeta_salida, exist_ok=True)
ruta_pdf = os.path.join(carpeta_salida, f"{pdf_name}.pdf")

doc = SimpleDocTemplate(ruta_pdf, pagesize=letter)
elements = []
styles = getSampleStyleSheet()

# Mostrar hashes de referencia
elements.append(Paragraph("Hashes de archivos de referencia:", styles["Heading4"]))
for ar, h in hashes_referencia.items():
    elements.append(Paragraph(f"{ar}: {h}", styles["Normal"]))
elements.append(Spacer(1, 0.2 * inch))

# Resumen
style_res = ParagraphStyle("Resumen", parent=styles["Normal"], leading=14)
texto_res = (
    f"Número llaves válidas generadas: {len(llaves_validas)}<br/>"
    f"Encontradas: {cnt_found}, suma de montos: {sum_found:.2f}<br/>"
    f"No encontradas: {cnt_no_found}, suma de montos: {sum_no_found:.2f}"
)
elements.append(Paragraph(texto_res, style_res))
elements.append(Spacer(1, 0.2 * inch))

# Excepciones
if excepciones:
    elements.append(Paragraph("Excepciones (columna B con valor inválido):", styles["Heading4"]))
    data_exc = [["Fila", "Valor B", "Motivo"]]
    for (fila, valb, mot) in excepciones:
        data_exc.append([str(fila), Paragraph(str(valb), styles["Normal"]), Paragraph(mot, styles["Normal"])])
    tabla_exc = Table(data_exc, colWidths=[1.0*inch, 3.5*inch, 2.0*inch])
    tabla_exc.setStyle(TableStyle([
        ('BACKGROUND', (0,0), (-1,0), colors.grey),
        ('TEXTCOLOR', (0,0), (-1,0), colors.whitesmoke),
        ('ALIGN', (0,0), (-1,-1), 'LEFT'),
        ('GRID', (0,0), (-1,-1), 0.5, colors.black),
        ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold'),
        ('VALIGN', (0,0), (-1,-1), 'TOP')
    ]))
    elements.append(tabla_exc)
    elements.append(Spacer(1, 0.3 * inch))

# Tabla llaves NO encontradas
elements.append(Paragraph("LLAVES NO ENCONTRADAS", styles["Heading4"]))
data_no = [[Paragraph(lk, styles["Normal"])] for lk in llaves_no_encontradas]
tabla_no = Table(data_no, colWidths=[6.5 * inch])
tabla_no.setStyle(TableStyle([('GRID', (0,0), (-1,-1), 0.5, colors.black)]))
elements.append(tabla_no)
elements.append(Spacer(1, 0.3 * inch))

# Tabla llaves ENCONTRADAS
elements.append(Paragraph("LLAVES ENCONTRADAS", styles["Heading4"]))
data_si = [[Paragraph(lk, styles["Normal"])] for lk in llaves_encontradas]
tabla_si = Table(data_si, colWidths=[6.5 * inch])
tabla_si.setStyle(TableStyle([('GRID', (0,0), (-1,-1), 0.5, colors.black)]))
elements.append(tabla_si)

doc.build(elements)

print("PDF generado:", ruta_pdf)
